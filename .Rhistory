find.package("devtools")
install.packages("devtools")
library(devtools)
library(devtools)
library()
install.packages(kernsmooth)
install.packages("KernSmooth")
library(KernSmooth)
install.packages("manipulate")
x<- matrix(rnorm(200), 20, 10)
apply(x, 2, mean)
x <- matrix (1:10, 4, 6)
x <- matrix (1:10, 2, 5)
x
apply (x, 2, mean)
apply (x, 1, sum)
rowsums(x)
rowSums(x)
colSums(x)
rowMeans(x)
rowSums(x)
colMeans(x)
apply(x, 1, quantile, probs = c(0.25, 0.75))
apply(x, 2, quantile, probs = c(0.25, 0.75))
a <- array(1:40, 2 * 2 * 10), c(2, 2, 10)
a <- array(1:40), c(2, 2, 10)
a <- array(1:40, c(2, 2, 10))
a
apply(a, c(1, 2), mean)
rowMeans(a, dims = 2)
str(mapply)
b <- list(rep(1,4), rep(2,3), rep(3,2), rep(4,1))
b
mapply(rep, 1:4, 4:1)
str(tapply)
## X is a vector
## index is a factor or a list of factors(or else they are coerced into factors)
## FUN is a function to be applied
## ... contains other args to be passed to FUN
## simplify = should we simplify the result?
## tapply applies a function over subsets of a vector
str(split)
## x is a vector (or list) of data frame
## f is a factor or a list of factors
## drop indicates whether empty factors levels should be dropped
?gl()
X <- c(rnorm(10), runif(10), rnorm(10,1))
x
f <- gl(3,10)
f
split(x, f)
x <- c(rnorm(10), runif(10), rnorm(10,1))
x
f <- gl(3,10)
f
split (x, f)
lapply(split(x, f), mean)
airquality<-read.csv("hw1_data.csv")
setwd("D:/OneDrive/R")
airquality<-read.csv("hw1_data.csv")
airquality
head(airquality)
## calc mean of each column, by month
s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
s
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
sapply(x, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind", na.rm=TRUE)]))
sapply(x, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind",)]), na.rm=TRUE)
sapply(x, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind",)]) na.rm=TRUE)
sapply(x, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind",)])), na.rm=TRUE
sapply(x, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind",)], na.rm=TRUE))
sapply(x, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")], na.rm=TRUE))
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")], na.rm=TRUE))
x <- rnorm(10)
f1 <- gl(2,5)
f2 <- gl(5,2)
f1
f2
interaction(f1, f2)
inter <- interaction(f1, f2)
str(split(x, inter))
str(split(x, inter), drop=TRUE)
split(x, inter), drop=TRUE)
str(split(x, inter), drop=TRUE)
str(split(x, list(f1, f2), drop=TRUE))
str(split(x, inter, drop=TRUE))
log(01)
log(-1)
printmessage <- function(X) {}
printmessage <- function(x) {
if(x>0)
print("x is greater than 0")
else
print("x is less than or equal to zero")
invisible(x)
}
printmessage(1)
printmessage(NA)
printmessage <- function(x) {
if(is.na(x))
print("x is a missing value!")
else if(x>0)
print("x is greater than 0")
else
print("x is less than or equal to zero")
invisible(x)
}
x <- log(-1)
printmessage(x)
mean(x)
traceback()
debug(lm)
lm(y-x)
options(error = recover)
read.csv("nosuchfile")
library(datasets)
data(iris)
?iris
isis
iris
split(iris, iris$species)
s <- split(iris, iris$Species)
s
apply(s, 2, mean)
apply(s$Sepal.Length, mean)
apply(s, mean)
> library(datasets)
> data(iris)
library(datasets)data(iris)
library(datasets)
data(iris)
iris
s <- split(iris)
s <- split(iris, iris$species)
s <- split(iris, iris$Species)
lapply(s, mean)
s
mean(s$virginica)
colmeans(s)
colMeans(s)
lapply(s, function(x) colMeans(x[, Sepal.Length]))
lapply(s, function(x) colMeans(Sepal.Length))
lapply(s, function(x) colMeans(x[, "Sepal.Length"]))
lapply(s, function(x) colMeans(x[, c("Sepal.Length", "Sepal.Width", "Petal.Length")]))
lapply(s, function(x) colMeans(x[, "Sepal.Length"]))
lapply(s, function(x) colMeans(x[, c("Sepal.Length")]))
lapply(s, function(x) colMeans(x[, c("Sepal.Length", "Sepal.Width")]))
z <- s$virginica
z
apply(z, mean)
lapply(z, mean)
lappy(z$Sepal.Length, mean)
lapply(z$Separl.Length, mean)
lapply(z$Sepal.Length, mean)
sapply(z$Sepal.Length, 2, mean)
sapply(z$Sepal.Length, mean
)
apply(z$Sepal.Length, mean)
apply(z$Sepal.Length, 2, mean)
apply(iris[, 1:4], 1, mean)
apply(iris, 2, mean)
colMeans(iris)
apply(iris[, 1:4], 2, mean)
library(datasets)
data(mtcars)
?mtcars
tapply(mtcars$cyl, mtcars$mpg, mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
apply(mtcars, 2, mean)
sapply(mtcars, cyl, mean)
tapply(mtcars$hp, mtcars$cyl, mean)
foo <- tapply(mtcars$hp, mtcars$cyl, mean)
foo
foo[8] - foo[4]
foo["8"] - foo["4"]
debug(ls)
ls
mat <- matrix(rnorm(1:100, 10, 10))
makeCacheMatrix(mat)
makeCacheMatrix <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
makeCacheMatrix(mat)
cached <- makeCacheMatrix(mat)
cacheSolve(cached)
mat <- matrix (rnorm(1:9), 3, 3)
cached <- makeCacheMatrix(mat)
cacheSolve(cached)
cacheSolve(cached)
cached
m
cached<-makeCacheMatrix(mat)
cacheSolve(cached)
cacheSolve(cached)
str(lm)
x <- rnorm(100,2,4)
summary(x)
str(x)
f <- gl(40,10)
f
str(f)
summary(f)
airquality <- read.csv("hw1_data.csv")
str(airquality)
m <- matrix(rnorm(100), 10, 10)
str(m)
m[,1]
s <- split(airquality, airquality$month)
s <- split(airquality, airquality$Month)
s
s$9
str(s)
with(airquality, tapply(Temp, Month, mean))
with(airquality, tapply(Ozone, Month, mean, na.rm=TRUE)
)
with(airquality, mean(Ozone))
with(airquality, mean(Ozone), na.rm=TRUE)
mean(airquality$Ozone)
with(airquality, mean(Ozone, na.rm=TRUE))
mean(airquality$Ozone, na.rm=TRUE)
Ozone <- airquality$Ozone, na.rm=TRUE
Ozone <- (airquality$Ozone, na.rm=True)
Ozone <- airquality$Ozone
Ozone
mean(Ozone, na.rm=TRUE)
bad <- complete.cases(Ozone)
Ozone <- Ozone(!bad)
Ozone <- Ozonne[!bad]
Ozone <- Ozone[!bad]
mean(Ozone)
Ozone
bad
Ozone <- Ozone[bad]
Ozone
Ozone <- airquality$Ozone
Ozone <- complete.cases(Ozone)
Ozone
Ozone <- Ozone[True]
Ozone <- airquality$Ozone
bad <- complete.cases(Ozone)
Ozone <- airquality$Ozone[!bad]
Ozone
Ozone <- airquality$Ozone
Ozone
good <- complete.cases(Ozone)
Ozone <- airquality$Ozone[good]
Ozone
mean(Ozone)
q18 <- data[(data$Ozone > 31) & (data$Temp > 90), ]
q18 <- airquality[(airquality$Ozone > 31) & (airquality$Temp > 90), ]
mean(q18, na.rm=TRUE)
q18
mean(q18$Solar.R, na.rm=TRUE)
q18 <- with(airquality, Ozone>31 & Temp > 90)
q18
q18 <- with(airquality, [(Ozone > 31) & (Temp > 90), ])
q18 <- with(airquality, airquality[(Ozone > 31) & (Temp > 90), ])
q18
q18 <- with(airquality, airquality[(Ozone > 31) & (Temp > 90), ], na.rm=TRUE)
q18
mean(q18$Solar.R)
mean(q18$Solar.R, na.rm=TRUE)
mean(with(airquality, airquality[(Ozone > 31) & (Temp > 90), ], na.rm=TRUE))
mean(airquality[(Ozone > 31) & (Temp > 90), ], na.rm=TRUE))
mean(airquality[(Ozone > 31) & (Temp > 90), ])
mean(airquality[(airquality$Ozone > 31) & (airquality$Temp > 90), ])
mean(with(airquality, airquality[(Ozone > 31) & (Temp > 90), ], na.rm=TRUE))
mean(q18$Solar.R, na.rm=TRUE)
mean(airquality$Temp[Month==6])
mean(airquality$Temp[airquality$Month==6])
mean(airquality$Temp[airquality$Month==6], na.rm=TRUE)
mean(with(airquality, Temp[Month==6]))
mean(with(airquality, Temp[Month==6]), na.rm=TRUE)
mean(with(airquality, Solar.R[(Ozone > 31) & (Temp > 90), ])
)
mean(with(airquality, Solar.R[(Ozone > 31) & (Temp > 90)]))
with(airquality, Solar.R[(Ozone > 31) & (Temp > 90)])
mean(with(airquality, Solar.R[(Ozone > 31) & (Temp > 90)]), na.rm=TRUE)
mean(airquality$Solar.R[(airquality$Ozone > 31) & (airquality$Temp > 90)]), na.rm=TRUE)
mean(airquality$Solar.R[(airquality$Ozone > 31) & (airquality$Temp > 90)], na.rm=TRUE)
max(airquality$Ozone[Month==5])
max(airquality$Ozone[airquality$Month==5])
max(airquality$Ozone[airquality$Month==5], na.rm=TRUE)
max(with(airquality, Ozone[Month==5]), na.rm=TRUE)
makeCacheMatrix <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)   ## makeCacheMatrix returns a list containing set,
}                                   ## get, setinverse, and getinverse functions to be used later
## with the cacheSolve function.
cacheSolve <- function(x, ...) {
m <- x$getinverse()                 ## m is assigned the value contained in the getinverse element of x
if(!is.null(m)) {                   ## if m is not null (meaning that the inverse has already been calculated & stored)
message("getting cached data")
return(m)                       ## return the value stored in m (the previously calculated inverse of the matrix)
}
data <- x$get()                     ## else, store the matrix in 'data' (retrieved from the get element in x)
m <- solve(data, ...)               ## run the solve function on data (calculate inverse of the matrix), store it in m
x$setinverse(m)                     ## store the result in the setinverse element of x (so it won't need to be calulated again)
m                                   ## return m, which now contains the inverse of the matrix
}
mat <- matrix (rnorm(9), 3, 3)
mat
made <- makeCacheMatrix(mat)
cacheSolve(made)
cacheSolve(made)
made
makeCacheMatrix <- function(x = numeric()) {
m <- NULL
set <- function(y) {                       ## set is assigned a function that initializes the x and m variables
x <<- y
m <<- NULL
}
get <- function() x                        ## get is assigned a function that returns the original matrix
setinverse <- function(solve) m <<- solve  ## setinverse is assigned a function that stores the solve function in m
getinverse <- function() m                 ## getinverse is assigned a function that returns the value stored in m
list(set = set, get = get,                 ## makeCacheMatrix returns a list containing set, get, setinverse,
setinverse = setinverse,              ## and getinverse, to be used later with the cacheSolve function.
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
m <- x$getinverse()                 ## m is assigned the value contained in the getinverse element of x
if(!is.null(m)) {                   ## if m is not null (meaning that the inverse has already been calculated & stored)
message("getting cached data")  ## print a line indicating you are retrieving the already-calculated inverse
return(m)                       ## return the value stored in m (the previously calculated inverse of the matrix)
}
data <- x$get()                     ## else, store the matrix in 'data' (retrieved from the get element in x)
m <- solve(data, ...)               ## run the solve function on data (calculate inverse of the matrix), store it in m
x$setinverse(m)                     ## store that result in the setinverse element of x (so it won't need to be calulated again)
m                                   ## return m, which now contains the inverse of the matrix
}
mat <- matrix (rnorm(100), 10, 10)
mat
made <- makeCacheMatrix(mat)
cacheSolve(made)
cacheSolve(made)
setwd("D:/OneDrive/R/GitHub/repos/ProgrammingAssignment2")
makeCacheMatrix <- function(x = numeric()) {
m <- NULL
set <- function(y) {                       ## set is assigned a function that initializes the x and m variables
x <<- y
m <<- NULL
}
get <- function() x                        ## get is assigned a function that returns the original matrix
setinverse <- function(solve) m <<- solve  ## setinverse is assigned a function that stores the solve function in m
getinverse <- function() m                 ## getinverse is assigned a function that returns the value stored in m
list(set = set, get = get,                 ## makeCacheMatrix returns a list containing set, get, setinverse,
setinverse = setinverse,              ## and getinverse, to be used later with the cacheSolve function.
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
m <- x$getinverse()                 ## m is assigned the value contained in the getinverse element of x
if(!is.null(m)) {                   ## if m is not null (meaning that the inverse has already been calculated & stored)
message("getting cached data")  ## print a line indicating you are retrieving the already-calculated inverse
return(m)                       ## return the value stored in m (the previously calculated inverse of the matrix)
}
data <- x$get()                     ## else, store the matrix in 'data' (retrieved from the get element in x)
m <- solve(data, ...)               ## run the solve function on data (calculate inverse of the matrix), store it in m
x$setinverse(m)                     ## store that result in the setinverse element of x (so it won't need to be calulated again)
m                                   ## return m, which now contains the inverse of the matrix
}
mat <- matrix (rnorm(100), 10, 10)
made <- makeCacheMatrix(mat)
cachesolve(made)
cacheSolve(made)
cacheSolve(made)
